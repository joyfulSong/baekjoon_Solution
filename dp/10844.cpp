// N자리수의 끝자리를 기준으로 그 끝자리 앞에 올 수 있는 경우인 +-1의 계단수를 가져온다

// 주의
// : 0으로 시작하는 수는 없지만 사이에는 0이 올 수 있다. (예: 10)
// : if - if - else 구조일 때는 j=0인 경우가 else에도 속하게 되어버리니 if- else if - else로 분기를 정확히 나눠야.
// : N = 100일때 보면, 가능한 계단수 갯수가 조단위가 넘어감. 1억으로 나눠야 한자리수가 됨.

// 1억으로 나눠주기에 int형 배열이어도 longlong(int 보다 네자리 더큼)일때랑 같은 출력결과가 나오는데, 각 Dp저장시마다 1억으로 나눠주지 않으면 오버플로우가 일어난다. 
// 나눠주지 않으면 longlong이어도 오버플로우 일어남. 

#include <iostream>

using namespace std;

#define Num 1000000000

int main()
{
	long long  Dp[101][10] = { 0 }; //입력은 100까지 가능(Dp[0]일때 사용안하니깐 1부터 필요), 끝자리는 1에서 9 가능, 0일때도 고려해야해서 10
	int N;
	long long ans = 0;
	cin >> N;

	for (int i = 1; i < 10; i++) {
		Dp[1][i] = 1; // 1자리일때 끝자리가 1부터 9까지일 때 계단수, 여기서부터 쌓아올림 (한자리인데 0일 수 없어서 9개)
	}

	for (int i = 2; i < N + 1; i++) { // 1자리수일 때는 저장했으니 2자리 부터
		for (int j = 0; j < 10; j++) {
			if (j == 0) {
				Dp[i][j] = (Dp[i - 1][j + 1]) % Num;
				//cout << "Dp[" << i << "][" << j << "]" << Dp[i][j] << "\n";
			}// 끝자리가 0이면 그 앞에는 1밖에 못온다. 그전자리수일 때 1로 끝났을 때의 갯수를 가져온다.
			else if (j == 9) {
				Dp[i][j] = (Dp[i - 1][j - 1]) % Num; // 끝자리가 9이면 그 앞에는 8밖에 못온다
				//cout << "Dp[" << i << "][" << j << "]" << Dp[i][j] << "\n";
			}
			else {
				Dp[i][j] = (Dp[i - 1][j - 1] + Dp[i - 1][j + 1]) % Num; // 끝자리가 1에서 8까지면 그 앞에 +-1의 수로 끝나는 경우가 올 수 있다.
				//cout << "Dp[" << i << "][" << j << "]" << Dp[i][j] << "\n";
			}
		}//매번 int 범위 초과하지 않기위해 나눠줌
	}

	for (int i = 0; i < 10; i++) {
		ans += (Dp[N][i]);
	}
	cout << ans % Num;

	return 0;
}