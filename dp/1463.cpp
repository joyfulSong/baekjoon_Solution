// dp, 점화식을 만들어 반복되는 작업을 저장(memoization)해둔다.
#include <iostream>
#include <algorithm>
using namespace std;

int Dp[1000001]; //입력 값이 최대 10의 6승 갯수의 배열, 0으로 초기화
	// 10이면 0부터 10까지 11개 단계에 대한 최소연산 횟수 저장이 필요하므로 

int main()
{
	int N;
	cin >> N;

	Dp[1] = 0;

	// 숫자 i에 대해서 나누기 2,3와 -1에 대해,
	// 작은 숫자들이 1이 되기까지의 최소 연산 횟수도 저장해둬서 그값과 비교
	for (int i = 2; i <= N; i++) {
		Dp[i] = Dp[i - 1] + 1; // 1을 빼는 연산에 대해
		if (i % 2 == 0) {
			Dp[i] = min(Dp[i / 2] + 1, Dp[i]);
		}
		if (i % 3 == 0) {
			Dp[i] = min(Dp[i / 3] + 1, Dp[i]);
 		}
	}
	// Dp[i/3]을 한 뒤에 +1을 하는 이유는, 
	// i/3의 숫자에서 1이 되기 위해 한 연산 수 + 해당 단계에서 나누기 3에 대한 연산을 한 것이므로
	// 6처럼 2,3으로 둘다 나눌수 있는 경우는, 첫번째 if에서 계산된 Dp[i]에 대해 비교 연산을 치루기에 갱신됨

	cout << Dp[N]; // N이라는 숫자를 1로 만들기 위한 최소 연산 횟수가 저장되어있음.
}