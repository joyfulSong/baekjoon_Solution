/* https://yabmoons.tistory.com/719 
 4 × 4 크기의 격자
 (r, c)는 격자의 r행 c열을 의미한다. 격자의 가장 왼쪽 윗 칸은 (1, 1)이고, 가장 오른쪽 아랫 칸은 (4, 4)
 물고기 M마리 (fx, fy, d)
	각 물고기는 격자의 칸 하나에 
	이동 방향을 가지고
		8가지 방향(상하좌우, 대각선)
			 방향은 8 이하의 자연수로 표현하고, 1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙
상어도 연습을 위해 격자의 한 칸에 (sx, sy)
둘 이상의 물고기가 같은 칸에 있을 수도 있으며, 마법사 상어와 물고기가 같은 칸에 있을 수도 있다.
연습 횟수 S


1. 상어가 모든 물고기에게 복제 마법. 5번에서 물고기가 복제되어 칸에 나타난
2. 모든 물고기가 한 칸 이동한다. 
	상어가 있는 칸, 물고기의 냄새가 있는 칸, 격자의 범위를 벗어나는 칸으로는 이동할 수 없다. 
	각 물고기는 자신이 가지고 있는 이동 방향이 이동할 수 있는 칸을 향할 때까지 방향을 45도 반시계 회전시킨다.
	만약, 이동할 수 있는 칸이 없으면 이동을 하지 않는다. 그 외의 경우에는 그 칸으로 이동을 한다. 
3. 상어가 연속해서 3칸 이동한다. 
		현재 칸에서 상하좌우로 인접한 칸
		연속해서 이동하는 칸 중에 격자의 범위를 벗어나는 칸이 있으면, 그 방법은 불가능한 이동 방법이다.
	연속해서 이동하는 중에 상어가 물고기가 있는 같은 칸으로 이동하게 된다면, 그 칸에 있는 모든 물고기는 격자에서 제외되며, 
		제외되는 모든 물고기는 물고기 냄새를 남긴다. 
	가능한 이동 방법 중에서 제외되는 물고기의 수가 가장 많은 방법으로 이동하며, 
		그러한 방법이 여러가지인 경우 사전 순으로 가장 앞서는 방법을 이용한다.
			최대 물고기 먹은 수 갱신 시 동일한건 비교하지 않는다. 이미 앞서 같은 수가 들어갔다면 그게 사전 순이 높기에.
			상은 1, 좌는 2, 하는 3, 우는 4
			!!!!!!!각각을 정수로 변환한 값을 a와 b라고 하자. a < b를 만족하면 A가 B보다 사전 순으로 앞선 것
			배열을 상좌하우로 넣어두면, 중복순열을 뽑을 때는 1번부터 순차적으로 뽑게된다.
			즉 ! 중복순열로 3개의 이동방향을 뽑았을 때, 가장 먼저 나오는 것은 '111' 즉, 상상상을 의미하게 된다.
			가장 마지막으로 나오는 것은 '444' 즉, 우우우가 될 것이다. 
4. 2회 전 연습에서의 물고기의 냄새가 격자에서 사라진다.
	if (time - smellMap[i][j] == 2) {
				smellMap[i][j] = 0;
5. 모든 복제된 물고기는 1에서의 위치와 방향을 그대로 갖게 된다.
*/

/*
* 4*4 map 원본, 복제마법용, 방향 이동용 <- vector<fish> fishMap[MAX][MAX]. push_back으로 방향 여러개 넣으려고.
* 이동방향 dr, dc
* 상어용 상하좌우
* 물고기 구조체
* 물고기 개수 저장 int, 상어 만나면 --
* 상어 pair
* 각 회차에서의 시간 기록 int time
* 
* 모든 물고기 한칸 이동 함수
*	방향 이동용에 담아둔다.
*	상어가 있는 칸, 물고기의 냄새가 있는 칸, 격자의 범위를 벗어나는 칸 확인 함수
* 반시계이동, 8~1 순으로 역순 돌리는 함수필요
* 상어 3칸 연속 이동: 4방향 3번고르기 -> 중복순열: dfs돌면서 3번째 호출했을 때의 물고기 수와 체크리스트 반환.
*										[상상상 이동 가능], [상하상 상상하가 다름]
*					한번 먹어보는 함수 만들어서 최대로 먹는 개수를 구한 뒤에 반환한다.
*	벡터: 방향 3가지 저장용
*	물고기수
*	조합이므로 순서 고려 안하니깐 idx 전달
	cnt 전달
*	
* 물고기 냄새: 음수 표시
* 
* 
*/
